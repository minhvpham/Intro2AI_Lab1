"""
PSO Exploitation Demo: Simple Unimodal Problem
===============================================
This file demonstrates how HIGH exploitation (low w, high c2 > c1) allows PSO 
to quickly converge on a simple unimodal problem (Sphere function).

Core Concept:
- Low w (inertia weight): Particles "brake" quickly, focus on current region
- High c2 (social coefficient): Strong pull toward global best (swarm consensus)
- Low c1 (cognitive coefficient): Less individual exploration, more conformity

Expected Behavior:
- Fast convergence to global optimum
- Efficient for simple problems with single optimum
- Risk: May converge prematurely on complex multimodal problems
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
import sys
from pathlib import Path

project_root = Path(__file__).parent.parent.parent
sys.path.insert(0, str(project_root))

from algo2_PSO.continuous.pso import PSO

# --- Sphere Function (Simple Unimodal) ---
def sphere(X):
    """
    Sphere function - SIMPLE UNIMODAL PROBLEM
    Global minimum: 0 at X = [0, 0]
    Single basin of attraction - no local minima
    """
    return np.sum(X**2, axis=0)

def sphere_plot(x, y):
    """Sphere function for 2D contour plot."""
    return x**2 + y**2


def run_exploitation_demo():
    """
    Run PSO on SPHERE function (simple problem) with HIGH EXPLOITATION settings.
    """
    print("=" * 70)
    print("EXPLOITATION DEMO: Simple Unimodal Problem (Sphere Function)")
    print("=" * 70)
    print("\nScenario: 2D Sphere function - Simple problem with single global optimum")
    print("Strategy: High Exploitation (Fast convergence, trust swarm consensus)")
    print("\nParameter Settings:")
    
    # Problem parameters
    dims = 2
    bounds_low = -10.0
    bounds_high = 10.0
    n_particles = 20
    max_iterations = 50  # Fewer iterations needed for simple problems
    
    # EXPLOITATION SETTINGS
    w = 0.4      # LOW: Particles brake quickly, limited momentum
    c1 = 1.0     # LOW: Less individual exploration
    c2 = 2.5     # HIGH: Strong pull toward global best (conformity)
    
    print(f"  • Inertia Weight (w) = {w:.2f}  [LOW - Quick braking]")
    print(f"  • Cognitive Coeff (c1) = {c1:.2f}  [LOW - Less individual search]")
    print(f"  • Social Coeff (c2) = {c2:.2f}  [HIGH - Strong swarm consensus]")
    print(f"  • Particles: {n_particles}")
    print(f"  • Max Iterations: {max_iterations}")
    print(f"\n{'Interpretation:':>20} c2 > c1 and low w → Fast convergence!")
    
    # Run PSO with exploitation settings
    print("\n" + "-" * 70)
    print("Running PSO with EXPLOITATION settings...")
    print("-" * 70)
    
    pso_exploit = PSO(
        obj_func=sphere,
        n_particles=n_particles,
        n_dims=dims,
        bounds_low=bounds_low,
        bounds_high=bounds_high,
        w=w,
        c1=c1,
        c2=c2
    )
    
    pos, fit, fit_hist, pos_hist, gbest_pos_hist = pso_exploit.optimize(max_iterations)
    
    print(f"\nBest Fitness: {fit:.6f}")
    print(f"Best Position: [{pos[0]:.6f}, {pos[1]:.6f}]")
    print(f"True Optimum: [0.000000, 0.000000]")
    print(f"Error: {np.sqrt(np.sum(pos**2)):.6f}")
    
    # For comparison, run with exploration settings
    print("\n" + "=" * 70)
    print("COMPARISON: Running with EXPLORATION settings on same problem")
    print("=" * 70)
    print("\nParameter Settings:")
    
    # EXPLORATION SETTINGS (not ideal for simple problems)
    w_explore = 0.9      # HIGH: Strong momentum
    c1_explore = 2.0     # HIGH: Individual exploration
    c2_explore = 1.0     # LOW: Weak swarm consensus
    
    print(f"  • Inertia Weight (w) = {w_explore:.2f}  [HIGH - Strong momentum]")
    print(f"  • Cognitive Coeff (c1) = {c1_explore:.2f}  [HIGH - Individual search]")
    print(f"  • Social Coeff (c2) = {c2_explore:.2f}  [LOW - Weak consensus]")
    print(f"\n{'Interpretation:':>20} c1 > c2 and high w → Slower convergence")
    
    print("\n" + "-" * 70)
    print("Running PSO with EXPLORATION settings...")
    print("-" * 70)
    
    pso_explore = PSO(
        obj_func=sphere,
        n_particles=n_particles,
        n_dims=dims,
        bounds_low=bounds_low,
        bounds_high=bounds_high,
        w=w_explore,
        c1=c1_explore,
        c2=c2_explore
    )
    
    pos_explore, fit_explore, fit_hist_explore, pos_hist_explore, gbest_pos_hist_explore = pso_explore.optimize(max_iterations)
    
    print(f"\nBest Fitness: {fit_explore:.6f}")
    print(f"Best Position: [{pos_explore[0]:.6f}, {pos_explore[1]:.6f}]")
    print(f"Error: {np.sqrt(np.sum(pos_explore**2)):.6f}")
    
    # Comparison summary
    print("\n" + "=" * 70)
    print("COMPARISON SUMMARY")
    print("=" * 70)
    print(f"{'Strategy':<20} {'Final Fitness':<20} {'Convergence Speed':<20}")
    print("-" * 70)
    
    # Calculate convergence iteration (when fitness < threshold)
    threshold = 0.01
    conv_iter_exploit = next((i for i, f in enumerate(fit_hist) if f < threshold), max_iterations)
    conv_iter_explore = next((i for i, f in enumerate(fit_hist_explore) if f < threshold), max_iterations)
    
    print(f"{'EXPLOITATION':<20} {fit:.6f}{'':<13} Iteration {conv_iter_exploit}")
    print(f"{'EXPLORATION':<20} {fit_explore:.6f}{'':<13} Iteration {conv_iter_explore}")
    print("-" * 70)
    
    if conv_iter_exploit < conv_iter_explore:
        speedup = (conv_iter_explore - conv_iter_exploit) / conv_iter_explore * 100
        print(f"\n✓ EXPLOITATION converges {speedup:.1f}% faster on this simple problem!")
    
    print("\n" + "=" * 70)
    print("KEY INSIGHT: For Simple Unimodal Problems")
    print("=" * 70)
    print("• Use LOW inertia (w ≈ 0.4-0.6) for quick braking")
    print("• Use HIGH social coefficient (c2 > c1) for fast consensus")
    print("• Exploitation settings achieve faster, more efficient convergence")
    print("• No risk of premature convergence since there's only one optimum!")
    
    return pso_exploit, pso_explore, fit_hist, fit_hist_explore


def create_visualization(pso_exploit, pso_explore, fit_hist_exploit, fit_hist_explore):
    """Create side-by-side convergence comparison."""
    
    fig, axes = plt.subplots(1, 2, figsize=(14, 5))
    
    # Left: Convergence curves
    ax1 = axes[0]
    ax1.semilogy(fit_hist_exploit, 'b-', linewidth=2, label='Exploitation (w=0.4, c1=1.0, c2=2.5)')
    ax1.semilogy(fit_hist_explore, 'r--', linewidth=2, label='Exploration (w=0.9, c1=2.0, c2=1.0)')
    ax1.axhline(y=0.01, color='g', linestyle=':', label='Threshold (0.01)')
    ax1.set_xlabel('Iteration', fontsize=12)
    ax1.set_ylabel('Best Fitness (log scale)', fontsize=12)
    ax1.set_title('Convergence Comparison: Sphere Function', fontsize=14, fontweight='bold')
    ax1.legend(loc='upper right')
    ax1.grid(True, alpha=0.3)
    
    # Right: Particle trajectories (last few iterations)
    ax2 = axes[1]
    
    # Create contour plot
    x = np.linspace(-10, 10, 100)
    y = np.linspace(-10, 10, 100)
    X, Y = np.meshgrid(x, y)
    Z = sphere_plot(X, Y)
    
    contours = ax2.contour(X, Y, Z, levels=20, cmap='viridis', alpha=0.6)
    ax2.clabel(contours, inline=True, fontsize=8)
    
    # Plot trajectories from exploitation run
    for i in range(pso_exploit.n_particles):
        traj = np.array([pos_hist_exploit[t][i] for t in range(len(pso_exploit.position_history))])
        ax2.plot(traj[:, 0], traj[:, 1], 'b-', alpha=0.3, linewidth=0.5)
    
    # Plot final positions
    final_pos_exploit = pso_exploit.position_history[-1]
    ax2.scatter(final_pos_exploit[:, 0], final_pos_exploit[:, 1], 
                c='blue', marker='o', s=50, alpha=0.7, label='Exploitation (final)')
    
    # Plot global optimum
    ax2.plot(0, 0, 'r*', markersize=20, label='Global Optimum')
    
    ax2.set_xlim([-10, 10])
    ax2.set_ylim([-10, 10])
    ax2.set_xlabel('x₁', fontsize=12)
    ax2.set_ylabel('x₂', fontsize=12)
    ax2.set_title('Particle Trajectories (Exploitation)', fontsize=14, fontweight='bold')
    ax2.legend(loc='upper right')
    ax2.grid(True, alpha=0.3)
    
    plt.tight_layout()
    
    # Save figure
    output_path = Path(__file__).parent / "exploitation_demo_sphere.png"
    plt.savefig(output_path, dpi=150, bbox_inches='tight')
    print(f"\n✓ Visualization saved: {output_path}")
    
    return fig


if __name__ == "__main__":
    # Run demo
    pso_exploit, pso_explore, fit_hist_exploit, fit_hist_explore = run_exploitation_demo()
    
    # Get position histories for visualization
    pos_hist_exploit = pso_exploit.position_history
    
    # Create visualization
    create_visualization(pso_exploit, pso_explore, fit_hist_exploit, fit_hist_explore)
    
    # Show plot
    plt.show()
    
    print("\n" + "=" * 70)
    print("Demo completed! Check 'exploitation_demo_sphere.png' for visualization.")
    print("=" * 70)
